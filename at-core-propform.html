<link rel="import" href="../at-core-form/at-core-form.html">

<dom-module id="at-core-propform">
  <style>

  </style>
  <template>
    <at-core-form id="propForm" hide="{{hide}}"></at-core-form>
  </template>
  <script>
    'use strict';
    Polymer({
      is: 'at-core-propform',
      properties: {
        elementInstance: {
          type: String,
          value: '',
          observer: 'elementInstanceChanged'
        },
        value: {
          type: Object,
          value: function() {
            return {};
          },
          observer: 'valueChanged'
        },
        mode: {
          type: String,
          value: 'default'
        },
        hide: {
          type: Boolean,
          value: false
        }
      },
      _scopeCssViaAttr: true,
      _isInternalUpdate: false,
      _boundPropertyChangedHandler: undefined,
      get schema() {
        var propForm = this.$.propForm;
        return propForm.schema;
      },
      attached: function() {
        this.resetResizeSensor();
      },
      ready: function() {
        var propForm = this.$.propForm;
        propForm.addEventListener('value-changed', function(event) {
          // we listen to value-changed event here to stop event bubbling from at-form-array when adding a new element
          // this may be a jquery issue though, because this happens in form designer which uses jquery
          event.stopPropagation();
        });

        var boundDataChanged = this._dataChanged.bind(this);
        propForm.addEventListener('data-changed', boundDataChanged);

        this.elementInstanceChanged(this.elementInstance, '');
      },
      resetResizeSensor: function() {
        var propForm = this.$.propForm;
        propForm.resetResizeSensor();
      },
      elementInstanceChanged: function(newValue, oldValue) {
        var propForm = this.$.propForm;
        propForm.data = {};

        if (!newValue || !newValue.properties) {
          return;
        }
        if (oldValue && oldValue.properties) {
          //detach events from previously bound element
          this._detachFromPropertyChangedEvents(oldValue);
        }

        var elementName = newValue;
        var self = this;
        var element = newValue;
        var properties = element.properties;
        var propertyNames = Object.keys(properties);
        var propDef;
        var schema = {
          title: elementName,
          description: 'Demo form for ' + elementName,
          properties: {}
        };
        var propSchemaDef = {};

        propertyNames.sort(function(param1, param2) {
          return param1 > param2;
        });

        propertyNames.forEach(function(propName, index) {
          propDef = properties[propName];
          if (self.mode === "default") {
            propSchemaDef = self._convertPolymerElementPropertyToAtCoreFormSchema(propName, propDef);
            schema.properties[propName] = propSchemaDef;
          } else if (self.mode === "designer" && propName !== "xtype") {
            propSchemaDef = self._convertPolymerElementPropertyToAtCoreFormSchema(propName, propDef);
            schema.properties[propName] = propSchemaDef;
          }
        });

        if (element.behaviors) {
          var bIndex;
          var bLength = element.behaviors.length;
          var behavior;

          for (bIndex = 0; bIndex < bLength; bIndex++) {
            behavior = element.behaviors[bIndex];
            if (behavior.properties) {
              propertyNames = Object.keys(behavior.properties);
              propertyNames.sort(function(param1, param2) {
                return param1 > param2;
              });
              propertyNames.forEach(function (propName, index) {
                propDef = behavior.properties[propName];
                propSchemaDef = self._convertPolymerElementPropertyToAtCoreFormSchema(propName, propDef);
                schema.properties[propName] = propSchemaDef;
              });
            }
          }
        }

        propForm.schema = schema;
        var initialData = {};
        schemaHelpers.copyProperties(Object.keys(schema.properties), [], element, initialData);
        propForm.data = initialData;

        // attach to element instance events
        this._attachToPropertyChangedEvents(this.elementInstance);

        this.resetResizeSensor();
      },
      _dataChanged: function(event) {
        event.stopPropagation();
        var value = event.detail.value;
        var propertyNames = Object.keys(value);
        if (!this._isInternalUpdate) {
          schemaHelpers.copyProperties(propertyNames, [], value, this.elementInstance);
          var elemName = this.elementInstance.is;
          if (["at-form-complex", "at-form-array"].indexOf(elemName) !== -1)  {
            this.elementInstance.valueChanged(value['value'], this.elementInstance.value);
          }
        }

        var value = event.detail.value;
        this.fire('value-changed', {
          value: value
        });
      },
      valueChanged: function(newValue, oldValue) {
        var propForm = this.$.propForm;
        propForm.data = newValue;
      },
      updateFormElementData: function(elementId, value) {
        var propForm = this.$.propForm;
        propForm.updateFormElementData(elementId, value);
      },
      resetResizeSensor: function() {
        var propForm = this.$.propForm;
        propForm.resetResizeSensor();
      },

      _attachToPropertyChangedEvents: function(elementInstance) {
        if (!elementInstance || !elementInstance.properties) {
          return;
        }

        if (!this._boundPropertyChangedHandler) {
          this._boundPropertyChangedHandler = this._propertyChangedHandler.bind(this);
        }

        var boundPropertyChangedHandler = this._boundPropertyChangedHandler;
        var propNames = Object.keys(elementInstance.properties);
        propNames.forEach(function(propName, index) {
          var eventName = propName + '-changed';
          elementInstance.addEventListener(eventName, boundPropertyChangedHandler);
        });

        if (elementInstance.behaviors) {
          var bIndex;
          var bLength = elementInstance.behaviors.length;
          var behavior;

          for (bIndex = 0; bIndex < bLength; bIndex++) {
            behavior = elementInstance.behaviors[bIndex];
            if (behavior.properties) {
              propNames = Object.keys(behavior.properties);
              propNames.forEach(function (propName, index) {
                var eventName = propName + '-changed';
                elementInstance.addEventListener(eventName, boundPropertyChangedHandler);
              });
            }
          }
        }
      },
      _detachFromPropertyChangedEvents: function(elementInstance) {
        if (!elementInstance || !elementInstance.properties) {
          return;
        }

        if (!this._boundPropertyChangedHandler) {
          this._boundPropertyChangedHandler = this._propertyChangedHandler.bind(this);
        }
        var boundPropertyChangedHandler = this._boundPropertyChangedHandler;
        var propNames = Object.keys(elementInstance.properties);
        propNames.forEach(function(propName, index) {
          var eventName = propName + '-changed';
          elementInstance.removeEventListener(eventName, boundPropertyChangedHandler);
        });

        if (elementInstance.behaviors) {
          var bIndex;
          var bLength = elementInstance.behaviors.length;
          var behavior;

          for (bIndex = 0; bIndex < bLength; bIndex++) {
            behavior = elementInstance.behaviors[bIndex];
            if (behavior.properties) {
              propNames = Object.keys(behavior.properties);
              propNames.forEach(function (propName, index) {
                var eventName = propName + '-changed';
                elementInstance.removeEventListener(eventName, boundPropertyChangedHandler);
              });
            }
          }
        }
      },
      _propertyChangedHandler: function(event) {
        var eventType = event.type;
        var element = event.target;
        var propForm = this.$.propForm;
        var self = this;
        if (eventType.indexOf('-') !== -1) {
          var propName = eventType.split('-')[0];
          self._isInternalUpdate = true;
          propForm.updateFormElementData(propName, element[propName]);
          self._isInternalUpdate = false;
        }
      },
      _convertPolymerElementPropertyToAtCoreFormSchema: function(polymerElementPropertyName, polymerElementPropertyDefinition) {
        var
          propName = polymerElementPropertyName,
          propDef = polymerElementPropertyDefinition,
          schema = {
            title: propName,
            description: 'Settings for ' + propName,
            properties: {}
          },
          tmpDef,
          propSchemaDef = {
            type: '',
            xtype: '',
            title: '',
            required: false,
            disabled: Boolean(propDef.readOnly),
            default: ''
          },
          propertyNameIgnoreList = ["type", "value", "reflectToAttribute", "readOnly", "notify", "computed", "observer", "defined"];

        // polymer project property definition is found here
        // https://www.polymer-project.org/1.0/docs/devguide/properties.html
        // propDef can be a function or a object
        // if its a function create a tmpDef with propDef.type = propDef
        if (window.schemaHelpers.isFunction(propDef)) {
          tmpDef = {
            type: propDef
          };
        } else {
          // else work with tmpDef = propDef
          tmpDef = propDef;
        }
        // set title to be property name
        propSchemaDef.title = propName;
        // convert type function to type string
        var computedType = 'object';
        if (tmpDef.type) {
          computedType = typeof tmpDef.type();
        } else {
          console.log('Can not determine the type of ' + propDef.type + '.');
          console.log('Using type object instead.');
        }
        if (computedType === "object") {
          if (isArray(tmpDef.type())) {
            computedType = "array";
          }
        }
        propSchemaDef.type = computedType;
        if (computedType === 'object') {
          propSchemaDef.xtype = 'json';
        }
        // convert value or value function to default
        var computedValue = tmpDef.value;
        if (window.schemaHelpers.notNull(tmpDef.value)) {
          if (isFunction(tmpDef.value)) {
            computedValue = tmpDef.value();
          }
          propSchemaDef.default = computedValue;
        }

        // copy over everything else, but ignore property names in propertyNameIgnoreList becase they do not make sense in at json schema
        var propertyNames = Object.keys(tmpDef);
        window.schemaHelpers.copyProperties(propertyNames, propertyNameIgnoreList, tmpDef, propSchemaDef);

        return propSchemaDef;
      }
    });
  </script>
</dom-module>
