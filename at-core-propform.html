<link rel="import" href="../at-core-form/at-core-form.html">

<dom-module id="at-core-propform">
  <style>

  </style>
  <template>
    <at-core-form id="propForm" hide="{{hide}}"></at-core-form>
  </template>
  <script>
    'use strict';
    Polymer({
      is: 'at-core-propform',
      properties: {
        elementInstance: {
          type: String,
          value: '',
          observer: 'elementInstanceChanged'
        },
        value: {
          type: Object,
          value: function() {
            return {};
          },
          observer: 'valueChanged'
        },
        mode: {
          type: String,
          value: 'default'
        },
        hide: {
          type: Boolean,
          value: false
        }
      },
      _scopeCssViaAttr: true,
      get schema() {
        var propForm = this.$.propForm;
        return propForm.schema;
      },
      attached: function() {
        this.resetResizeSensor();
      },
      ready: function() {
        this._boundValueChangedHandler = this._elementValueChangedHandler.bind(this);
        this._boundValidChangedHandler = this._elementValidChangedHandler.bind(this);
        this._boundDataChanged = this._dataChanged.bind(this);
        this._boundAtFormDateFormatChangedHandler = this._atFormDateFormatChangedHandler.bind(this);
        this._boundStartDateChangedHandler = this._startDateChangedHandler.bind(this);
        this._boundEndDateChangedHandler = this._endDateChangedHandler.bind(this);

        var propForm = this.$.propForm;
        propForm.addEventListener('data-changed', this._boundDataChanged);

        propForm.addEventListener('value-changed', function(event) {
          // we listen to value-changed event here to stop event bubbling from at-form-array when adding a new element
          // this may be a jquery issue though, because this happens in form designer which uses jquery
          event.stopPropagation();
        });

        this.elementInstanceChanged(this.elementInstance, '');
      },
      resetResizeSensor: function() {
        var propForm = this.$.propForm;
        propForm.resetResizeSensor();
      },
      elementInstanceChanged: function(newValue, oldValue) {
        var propForm = this.$.propForm;
        propForm.data = {};

        if (!newValue || !newValue.properties) {
          return;
        }
        if (oldValue && oldValue.properties) {
          //detach events from previously bound element
          oldValue.removeEventListener('value-changed', this._boundValueChangedHandler);
          oldValue.removeEventListener('valid-changed', this._boundValidChangedHandler);
          if (oldValue.is === 'at-form-date') {
            oldValue.removeEventListener('format-changed', this._boundAtFormDateFormatChangedHandler);
          } else if (oldValue.is === 'at-form-daterange') {
            oldValue.removeEventListener('start-date-changed', this._boundStartDateChangedHandler);
            oldValue.removeEventListener('end-date-changed', this._boundEndDateChangedHandler);
          }
        }

        var elementName = newValue;
        var self = this;
        var element = newValue;
        var properties = element.properties;
        var propertyNames = Object.keys(properties);
        var propDef;
        var schema = {
          title: elementName,
          description: 'Demo form for ' + elementName,
          properties: {}
        };
        var propSchemaDef = {};

        propertyNames.sort(function(param1, param2) {
          return param1 > param2;
        });

        propertyNames.forEach(function(propName, index) {
          propDef = properties[propName];
          if (self.mode === "default") {
            propSchemaDef = self._convertPolymerElementPropertyToAtCoreFormSchema(propName, propDef);
            schema.properties[propName] = propSchemaDef;
          } else if (self.mode === "designer" && propName !== "xtype") {
            propSchemaDef = self._convertPolymerElementPropertyToAtCoreFormSchema(propName, propDef);
            schema.properties[propName] = propSchemaDef;
          }
        });
        propForm.schema = schema;
        var initialData = {};
        schemaHelpers.copyProperties(Object.keys(schema.properties), [], element, initialData);
        propForm.data = initialData;

        element.addEventListener('value-changed', this._boundValueChangedHandler);
        element.addEventListener('valid-changed', this._boundValidChangedHandler);
        if (element.is === 'at-form-date') {
          element.addEventListener('format-changed', this._boundAtFormDateFormatChangedHandler);
        } else if (element.is === 'at-form-daterange') {
          element.addEventListener('start-date-changed', this._boundStartDateChangedHandler);
          element.addEventListener('end-date-changed', this._boundEndDateChangedHandler);
        }

        this.resetResizeSensor();
      },
      _elementValueChangedHandler: function(event) {
        var propForm = this.$.propForm;
        var newValue = event.detail.value;
        this.debounce('updateFormElementData', function (event) {
          propForm.updateFormElementData('value', newValue);
        }, 200);
      },
      _elementValidChangedHandler: function(event) {
        var propForm = this.$.propForm;
        var newValue = event.detail.value;
        propForm.updateFormElementData('valid', newValue);
      },
      _atFormDateFormatChangedHandler: function (event) {
        var propForm = this.$.propForm;
        var newValue = event.detail.value;
        propForm.updateFormElementData('format', newValue);
      },
      _startDateChangedHandler: function (event) {
        var propForm = this.$.propForm;
        var newValue = event.detail.value;
        propForm.updateFormElementData('startDate', newValue);
      },
      _endDateChangedHandler: function (event) {
        var propForm = this.$.propForm;
        var newValue = event.detail.value;
        propForm.updateFormElementData('endDate', newValue);
      },
      _dataChanged: function(event) {
        event.stopPropagation();
        var value = event.detail.value;
        var propertyNames = Object.keys(value);
        schemaHelpers.copyProperties(propertyNames, [], value, this.elementInstance);

        var value = event.detail.value;
        this.fire('value-changed', {
          value: value
        });
      },
      valueChanged: function(newValue, oldValue) {
        var propForm = this.$.propForm;
        propForm.data = newValue;
      },
      updateFormElementData: function(elementId, value) {
        var propForm = this.$.propForm;
        propForm.updateFormElementData(elementId, value);
      },
      resetResizeSensor: function() {
        var propForm = this.$.propForm;
        propForm.resetResizeSensor();
      },
      _convertPolymerElementPropertyToAtCoreFormSchema: function(polymerElementPropertyName, polymerElementPropertyDefinition) {
        var
          propName = polymerElementPropertyName,
          propDef = polymerElementPropertyDefinition,
          schema = {
            title: propName,
            description: 'Settings for ' + propName,
            properties: {}
          },
          tmpDef,
          propSchemaDef = {
            type: '',
            xtype: '',
            title: '',
            required: false,
            disabled: false,
            default: ''
          },
          propertyNameIgnoreList = ["type", "value", "reflectToAttribute", "readOnly", "notify", "computed", "observer", "defined"];

        // polymer project property definition is found here
        // https://www.polymer-project.org/1.0/docs/devguide/properties.html
        // propDef can be a function or a object
        // if its a function create a tmpDef with propDef.type = propDef
        if (window.schemaHelpers.isFunction(propDef)) {
          tmpDef = {
            type: propDef
          };
        } else {
          // else work with tmpDef = propDef
          tmpDef = propDef;
        }
        // set title to be property name
        propSchemaDef.title = propName;
        // convert type function to type string
        var computedType =  'string';
        if (tmpDef.type) {
          computedType = typeof tmpDef.type();
        } else {
          console.log('Can not determine the type of ' + propDef.type + '.');
          console.log('Using type string instead.');
        }
        if (computedType === "object") {
          if (isArray(tmpDef.type())) {
            computedType = "array";
          }
        }
        propSchemaDef.type = computedType;
        if (computedType === 'object') {
          propSchemaDef.xtype = 'json';
        }
        // convert value or value function to default
        var computedValue = tmpDef.value;
        if (window.schemaHelpers.notNull(tmpDef.value)) {
          if (isFunction(tmpDef.value)) {
            computedValue = tmpDef.value();
          }
          propSchemaDef.default = computedValue;
        }

        // copy over everything else, but ignore property names in propertyNameIgnoreList becase they do not make sense in at json schema
        var propertyNames = Object.keys(tmpDef);
        window.schemaHelpers.copyProperties(propertyNames, propertyNameIgnoreList, tmpDef, propSchemaDef);

        return propSchemaDef;
      }
    });
  </script>
</dom-module>
